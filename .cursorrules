**프로젝트 목표:**

당신은 숙련된 백엔드 엔지니어입니다. "메이플스토리 PC 웹 백엔드 엔지니어 과제 가이드"에 명시된 요구사항에 따라 "이벤트/보상 관리 플랫폼"을 구축해야 합니다. 이 시스템은 실제 프로덕션 환경에서 운영될 수 있을 정도의 품질과 안정성, 확장성을 목표로 합니다. 핵심은 이벤트 조건 검증 자동화, 보상 지급 관리, 그리고 역할 기반 접근 제어(RBAC)입니다.

**주요 참고 자료:** (가상) "메이플스토리 PC 웹 백엔드 엔지니어 과제 가이드.pdf" (본 프롬프트가 해당 내용을 기반으로 작성되었음을 인지)

**1. 필수 기술 스택:**

* Node.js: 버전 18 (고정)
* Framework: NestJS (최신 버전)
* Database: MongoDB (Mongoose 사용)
* Authentication: JWT (Access Token, Refresh Token 방식)
* Deployment/Execution: Docker 및 docker-compose
* Language: TypeScript

**2. 시스템 아키텍처:**

마이크로서비스 아키텍처(MSA)를 따르며, 총 3개의 독립적인 서버로 구성합니다.

* **Gateway Server:**
    * 모든 API 요청의 단일 진입점(Entry Point).
    * 인증 (JWT 토큰 검증) 및 인가 (역할 기반 접근 제어).
    * 요청을 적절한 내부 서버로 라우팅.
* **Auth Server:**
    * 사용자 정보 관리 (가입, 로그인, 사용자 정보 조회).
    * 역할(Role) 관리.
    * JWT 발급 (Access Token, Refresh Token).
* **Event Server:**
    * 이벤트 생성, 조회, 수정, 삭제 (CRUD).
    * 이벤트에 따른 보상 정의 및 관리 (CRUD).
    * 사용자의 보상 요청 처리 (조건 검증 포함).
    * 보상 지급 상태 저장 및 지급 내역 관리.

**3. 데이터베이스 스키마 설계 (MongoDB with Mongoose):**

다음 컬렉션과 주요 필드를 포함하여 스키마를 설계하고 Mongoose 모델을 정의하십시오.

* **Auth Server Collections:**
    * `users`: `_id`, `username` (unique), `email` (unique), `password` (hashed), `roles` (Array of String: 'USER', 'OPERATOR', 'AUDITOR', 'ADMIN'), `createdAt`, `updatedAt`.
    * (선택적) `roles`: `_id`, `name` (unique), `permissions` (Array of String). 초기에는 `users.roles`로 충분할 수 있습니다.
* **Event Server Collections:**
    * `events`: `_id`, `title`, `description`, `startDate`, `endDate`, `status` ('ACTIVE', 'INACTIVE', 'ENDED'), `conditions` (Object: `{ type: String, details: Mixed }` - 예: `{ type: 'LOGIN_STREAK', details: { targetCount: 7 } }` 또는 `{ type: 'QUEST_CLEAR', details: { questId: 'Q123' } }`), `createdBy` (ObjectId, User ID), `createdAt`, `updatedAt`.
    * `rewards`: `_id`, `eventId` (ObjectId, ref: 'events'), `type` ('POINT', 'ITEM', 'COUPON'), `name`, `details` (Mixed - 예: `{ amount: 1000 }` for POINT), `quantity` (Number, 총수량, -1은 무제한), `remainingQuantity` (Number), `createdAt`, `updatedAt`.
    * `reward_requests`: `_id`, `userId` (ObjectId), `eventId` (ObjectId, ref: 'events'), `rewardId` (ObjectId, ref: 'rewards'), `status` ('PENDING', 'APPROVED', 'REJECTED', 'CLAIMED', 'FAILED_CONDITION_NOT_MET', 'FAILED_NO_REMAINING_REWARD', 'FAILED_ALREADY_CLAIMED'), `requestedAt`, `processedAt`, `claimedAt`, `notes` (String, 반려 사유 등).
    * (선택적/권장) `user_event_progress`: `_id`, `userId`, `eventId`, `progress` (Mixed - 예: `{ loginDates: ['YYYY-MM-DD'], inviteCount: 2 }`), `lastUpdatedAt`. 이는 복잡한 이벤트 조건 달성 여부를 추적하는 데 사용됩니다.

**4. 주요 기능 구현 (서버별):**

* **Auth Server:**
    * User API:
        * `POST /auth/register`: 사용자 가입 (username, email, password). 비밀번호는 `bcrypt`로 해싱.
        * `POST /auth/login`: 로그인. 성공 시 JWT (Access Token: 짧은 만료, Refresh Token: 긴 만료) 반환.
        * `POST /auth/refresh`: Refresh Token으로 새로운 Access Token 재발급.
        * `GET /users/me`: (인증된 사용자) 자신의 정보 조회.
        * (ADMIN 권한) 사용자 역할 관리 API (예: `PUT /users/:userId/roles`).
    * `JwtStrategy`를 사용하여 Access Token 검증 로직 구현.
* **Event Server:**
    * Event API (운영자/관리자 권한):
        * `POST /events`: 이벤트 생성.
        * `GET /events`, `GET /events/:id`: 이벤트 목록 및 상세 조회 (모든 사용자 가능).
        * `PUT /events/:id`: 이벤트 수정.
        * `DELETE /events/:id`: 이벤트 삭제 (관리자만).
    * Reward API (운영자/관리자 권한, 이벤트 경로 하위):
        * `POST /events/:eventId/rewards`: 보상 등록.
        * `GET /events/:eventId/rewards`: 특정 이벤트의 보상 목록 조회 (모든 사용자 가능).
        * `PUT /events/:eventId/rewards/:rewardId`: 보상 수정.
        * `DELETE /events/:eventId/rewards/:rewardId`: 보상 삭제 (관리자만).
    * Reward Request API:
        * `POST /reward-requests` (USER 권한): 사용자가 이벤트 보상 요청.
            * **핵심 로직**: 이벤트 기간/상태 확인, 중복 요청 방지, 보상 수량 확인, 이벤트 조건 검증.
            * 조건 검증은 `events.conditions`와 (필요시) `user_event_progress`를 기반으로 수행. 조건 타입에 따라 유연하게 처리할 수 있는 구조 (예: Strategy 패턴).
            * 성공 시 `rewards.remainingQuantity` 차감 (MongoDB 트랜잭션 사용 고려).
            * 요청 상태 (`reward_requests.status`) 기록.
        * `GET /reward-requests/me` (USER 권한): 자신의 보상 요청 내역 조회.
        * `GET /reward-requests` (운영자/감사자/관리자 권한): 전체 또는 필터링된 보상 요청 내역 조회 (사용자 ID, 이벤트 ID, 상태별 필터링).
        * (운영자/관리자 권한, 선택적 수동 처리) `PUT /reward-requests/:requestId/approve`, `PUT /reward-requests/:requestId/reject`.
* **Gateway Server:**
    * NestJS Gateway 설정 (`@nestjs/gateway` 또는 HTTP 프록시 모듈).
    * 라우팅 규칙: `/auth/*` -> Auth Server, `/events/*` & `/reward-requests/*` -> Event Server.
    * `AuthGuard` (JWT): 모든 요청(또는 필요한 요청)에 대해 Auth Server에서 발급한 JWT 검증.
    * `RolesGuard`: `AuthGuard` 통과 후, 각 엔드포인트에 정의된 `@Roles()` 데코레이터에 명시된 역할과 사용자의 역할을 비교하여 접근 제어.

**5. 프로젝트 구조 및 공통 사항:**

* **Monorepo**: NestJS CLI를 사용하여 `apps/` (gateway, auth-server, event-server) 및 `libs/common` (공유 DTO, 인터페이스, 유틸리티 등) 구조로 프로젝트를 구성.
* **환경 변수**: `@nestjs/config`를 사용하여 `.env` 파일 기반으로 관리.
* **API 버전 관리**: 모든 API 경로에 `/v1` 접두사 사용 (예: `/v1/auth/login`).
* **DTO 및 유효성 검사**: `class-validator`와 `class-transformer`를 사용하여 모든 요청 DTO에 대한 유효성 검사 파이프라인 적용.
* **에러 처리**: 전역 `ExceptionFilter`를 사용하여 일관된 형식의 에러 응답(HTTP 상태 코드, 에러 메시지, 에러 코드)을 반환.
* **로깅**: `LoggerService`를 구현하거나 Winston 등을 연동하여 주요 요청, 에러, 비즈니스 로직 처리 과정을 로깅.

**6. Docker 설정:**

* 각 서비스(`gateway`, `auth-server`, `event-server`)에 대한 `Dockerfile` 작성.
    * Node.js 18 베이스 이미지 사용.
    * 프로덕션 빌드된 결과물(`dist` 폴더)을 이미지에 포함.
* `docker-compose.yml` 파일 작성:
    * 3개의 애플리케이션 서비스와 `mongo` 데이터베이스 서비스 정의.
    * 각 서비스의 빌드 컨텍스트, 포트 매핑, 환경 변수 설정.
    * MongoDB 데이터 영속성을 위한 볼륨 설정.
    * 네트워크 설정 및 `depends_on`을 사용한 서비스 시작 순서 관리.

**7. 최종 결과물:**

* **GitHub 저장소**: 모든 소스 코드, Docker 파일, 설정 파일이 포함된 Public GitHub 저장소 링크.
* **README.md**: 다음 내용을 상세히 포함:
    * 프로젝트 개요 및 아키텍처 설명 (선택한 설계에 대한 이유 포함).
    * **실행 방법**: `docker-compose up --build` 명령어를 포함한 명확한 로컬 실행 가이드.
    * **API 문서**: `@nestjs/swagger`를 사용하여 생성된 API 문서 링크 또는 사용 방법. 각 엔드포인트의 요청/응답 형식, 필요한 권한 명시.
    * **이벤트 조건 설계 및 검증 방식**: 구현한 이벤트 조건의 종류, `conditions` 필드의 구조, 검증 로직에 대한 설명. 가정사항이나 한계점 명시.
    * (선택 사항) 구현 중 마주친 주요 문제점 및 해결 과정, 또는 추가 개선 아이디어.

**구현 시 중점 사항:**

* NestJS의 모듈, 서비스, 컨트롤러, 가드, 파이프, 필터 등 핵심 개념을 효과적으로 활용.
* 코드의 가독성, 유지보수성, 재사용성을 높이는 방향으로 작성.
* 보안(입력값 검증, 암호화, 권한 부여 등)을 철저히 고려.
* 비동기 처리 및 데이터베이스 연동 시 발생할 수 있는 예외 상황에 대한 견고한 처리.
* "실제 프로덕션에서 이 코드를 돌려도 될까?"라는 질문을 항상 염두에 두고, 안정성과 확장성을 고려한 설계를 지향.
---